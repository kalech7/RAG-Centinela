\begin{Verbatim}[commandchars=\\\{\}]
FUN segmentar\PYGZus{}oraciones():
  IN=\PYGZdq{}processed\PYGZus{}lbl.parquet\PYGZdq{}; OUT=\PYGZdq{}processed\PYGZus{}sentences.parquet\PYGZdq{}; COL=\PYGZdq{}abstract\PYGZus{}norm\PYGZdq{}

  df ← leer\PYGZus{}parquet(IN, prefer fastparquet → pyarrow)
  lang ← df[\PYGZdq{}lang\PYGZdq{}] si existe; si no → \PYGZdq{}es\PYGZdq{}

  seg\PYGZus{}es←pysbd(es); seg\PYGZus{}en←pysbd(en)
  split(text, lg): si vacío→[]; usar seg\PYGZus{}en si lg inicia \PYGZdq{}en\PYGZdq{}, sino seg\PYGZus{}es; si error→[text]

  df[\PYGZdq{}sentences\PYGZdq{}] ← map(split, df[COL], lang)
  out ← explode(df,\PYGZdq{}sentences\PYGZdq{}); renombrar a \PYGZdq{}sentence\PYGZdq{}
  out ← add row\PYGZus{}id\PYGZus{}original (índice) y sentence\PYGZus{}idx (cumcount por row\PYGZus{}id)
  out ← columnas [scopus\PYGZus{}id?, title?, abstract?, abstract\PYGZus{}norm?, lang?, row\PYGZus{}id\PYGZus{}original, sentence\PYGZus{}idx, sentence]

  guardar\PYGZus{}parquet(out, OUT, prefer fastparquet(gzip) → pyarrow → CSV)
\end{Verbatim}
